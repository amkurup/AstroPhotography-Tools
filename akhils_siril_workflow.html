<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akhil's Astro Processing Workflow</title>
    <!-- Removed external Google Fonts for offline security -->
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-primary: #58a6ff;
            --accent-secondary: #a5a5ff;
            --highlight-bg: #1f3a5f;
            --highlight-text: #79c0ff;
            --note-bg: #1c2128;
            --note-border: var(--accent-primary);
            --header-border: #30363d;
            --table-border: #30363d;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #f85149;
            --progress-track: #21262d;
            --progress-fill: var(--accent-primary);
            --ring: 0 0 0 3px rgba(88, 166, 255, 0.15);
            --success-color: #56d364;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            margin: 0;
            padding: 1.5rem;
            font-weight: 400;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--bg-secondary);
            padding: 2rem 2.5rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px var(--shadow-color);
            border: 1px solid var(--header-border);
        }

        header {
            text-align: center;
            margin-bottom: 2.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--header-border);
            position: sticky;
            top: 0;
            z-index: 10;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(8px);
            transition: padding 180ms ease;
        }

        h1,
        h2,
        h3 {
            font-family: Georgia, "Times New Roman", Times, serif;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
            transition: opacity 180ms ease, transform 180ms ease, margin 180ms ease, max-height 180ms ease;
        }

        header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
            transition: opacity 180ms ease, transform 180ms ease, margin 180ms ease, max-height 180ms ease;
        }

        /* Header compact-on-scroll state */
        header.compact-scrolled {
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            min-height: 28px;
        }
        
        header.compact-scrolled .search-tools { 
            transition: opacity 180ms ease, max-height 180ms ease, margin 180ms ease; 
        }
        
        header.compact-scrolled .search-tools {
            opacity: 0;
            max-height: 0;
            margin: 0;
            pointer-events: none;
        }

        h2 {
            font-size: 1.9rem;
            font-weight: 700;
            color: var(--accent-secondary);
            border-bottom: 1px solid var(--header-border);
            padding-bottom: 0.85rem;
            margin-top: 0;
            margin-bottom: 2rem;
            position: relative;
            padding-right: 2rem;
        }

        h3 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
        }

        .phase {
            margin-bottom: 4rem;
        }

        .checklist-item {
            margin-bottom: 1rem;
            display: flex;
            align-items: flex-start;
            padding: 16px 20px;
            border: 1px solid var(--header-border);
            border-radius: 8px;
            background: var(--bg-secondary);
            transition: all 150ms ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .checklist-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--accent-primary);
        }

        .checklist-item input[type="checkbox"] {
            appearance: none;
            background-color: white;
            border: 2px solid var(--header-border);
            border-radius: 4px;
            cursor: pointer;
            margin-right: 16px;
            margin-top: 4px;
            min-width: 20px;
            min-height: 20px;
            position: relative;
            transition: all 0.2s ease;
        }

        .checklist-item input[type="checkbox"]:checked {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        .checklist-item input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .checklist-item input[type="checkbox"]:focus-visible {
            outline: none;
            box-shadow: var(--ring);
        }

        .checklist-item label {
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .checklist-item .item-content {
            flex-grow: 1;
        }

        .highlight-term {
            background-color: var(--highlight-bg);
            color: var(--highlight-text);
            padding: 3px 8px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        .note {
            background-color: var(--note-bg);
            border-left: 5px solid var(--note-border);
            padding: 15px 20px;
            margin-top: 12px;
            border-radius: 8px;
            font-size: 0.98em;
            color: var(--text-secondary);
        }

        .note a {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: bold;
        }

        .note a:hover {
            text-decoration: underline;
        }

        .note strong {
            color: #98C379;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--table-border);
        }

        th,
        td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--table-border);
        }

        th {
            background-color: var(--bg-tertiary);
            color: var(--accent-primary);
            font-weight: 700;
            font-family: 'Roboto Slab', serif;
        }

        td {
            background-color: var(--bg-secondary);
        }

        td strong {
            color: var(--text-primary);
        }

        tbody tr:hover td {
            background-color: var(--bg-tertiary);
        }

        table tr:last-child td {
            border-bottom: none;
        }

        .button-container {
            text-align: center;
            margin-top: 2.5rem;
        }

        .palette-selector {
            background: var(--bg-secondary);
            border: 1px solid var(--header-border);
            padding: 20px;
            margin-top: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .palette-selector label {
            font-weight: 700;
            color: var(--accent-secondary);
            margin-right: 12px;
            font-size: 1.1em;
        }

        .palette-selector select {
            padding: 10px 14px;
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--table-border);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 1em;
            transition: all 180ms ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23c8ccd4' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px 16px;
            padding-right: 42px;
        }

        .palette-selector select:hover {
            border-color: var(--accent-primary);
        }

        .palette-selector select:focus {
            outline: none;
            box-shadow: var(--ring);
        }

        .palette-info {
            margin-top: 18px;
            padding-top: 18px;
            border-top: 1px solid var(--header-border);
        }

        .palette-info h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 1.15rem;
        }

        .palette-info pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--header-border);
            padding: 15px;
            border-radius: 6px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-primary);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .palette-actions {
            margin-top: 12px;
            display: flex;
            gap: .5rem;
        }

        

        .target-selector-container,
        .project-manager-container {
            background-color: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border: 1px solid var(--header-border);
        }

        .selectors-wrapper {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .selectors-wrapper {
                grid-template-columns: 1fr;
            }
        }

        /* Removed unused .select-card styles */

        .project-manager-container label,
        .target-selector-container label {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            display: block;
            margin-bottom: 1rem;
        }

        .project-manager-container input,
        .project-manager-container select,
        .target-selector-container select {
            width: 100%;
            padding: 12px;
            border-radius: 6px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--table-border);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 1em;
            margin-bottom: 1rem;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23c8ccd4' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px 16px;
            padding-right: 42px;
        }

        .project-manager-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Modern button styles */
        .project-manager-buttons button {
            flex-grow: 1;
            padding: 10px 18px;
            font-size: 0.95em;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: all 200ms ease;
            border: none;
        }

        #newProjectButton {
            background: var(--accent-primary);
            color: white;
        }

        #newProjectButton:hover {
            background: #3182ce;
        }

        #deleteProjectButton {
            background: var(--danger-color);
            color: white;
        }

        #deleteProjectButton:hover {
            background: #c53030;
        }

        button#resetButton {
            background: var(--danger-color);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1.05em;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            border-radius: 6px;
            cursor: pointer;
            transition: all 200ms ease;
        }

        button#resetButton:hover {
            background: #c53030;
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--bg-tertiary), #495066);
            color: var(--text-primary);
            border: none;
            padding: 10px 16px;
            font-size: .95rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 180ms ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, var(--accent-primary), #4a9eff);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(97, 175, 239, 0.25);
        }

        
        .progress {
            margin-top: 1.25rem;
        }

        .progress-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .progress-track {
            height: 8px;
            background: var(--progress-track);
            border-radius: 4px;
            overflow: hidden;
        }

        #progress-fill {
            height: 100%;
            width: 0%;
            background: var(--progress-fill);
            transition: width 200ms ease;
            border-radius: 4px;
        }

        #progress-count {
            color: var(--text-primary);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        /* Collapsed phases strip under progress when scrolled */
        .collapsed-phases-strip {
            display: none;
            gap: .5rem;
            margin-top: .5rem;
            padding: .25rem 0;
            overflow-x: auto;
            white-space: nowrap;
        }
        header.compact-scrolled .collapsed-phases-strip {
            display: flex;
            align-items: center;
            animation: fadeSlideDown 180ms ease;
        }
        .phase-chip {
            background: var(--bg-tertiary);
            border: 1px solid var(--header-border);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: .85rem;
            cursor: pointer;
            transition: border-color 120ms ease;
        }
        .phase-chip:hover { border-color: var(--accent-primary); }
        .phase-chip .count { color: var(--text-secondary); margin-left: .35rem; font-variant-numeric: tabular-nums; }

        /* Collapsible phases with smooth animations */
        .phase {
            transition: margin-bottom 240ms ease;
        }
        
        .phase .toggle-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--header-border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 180ms ease;
            font-size: 16px;
        }

        .phase .toggle-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .phase .phase-content {
            overflow: hidden;
            transition: max-height 280ms ease, opacity 200ms ease;
            max-height: 5000px;
            opacity: 1;
        }

        .phase.collapsed .phase-content {
            max-height: 0;
            opacity: 0;
        }

        .phase.collapsed {
            margin-bottom: 1rem;
        }

        .project-manager-container h3 {
            position: relative;
            padding-right: 2.25rem;
        }

        /* Animate PM collapse using max-height + opacity */
        .project-manager-container .pm-content {
            overflow: hidden;
            transition: max-height 240ms ease, opacity 180ms ease;
            max-height: 1200px;
            opacity: 1;
        }
        .project-manager-container.collapsed .pm-content {
            max-height: 0;
            opacity: 0;
        }

        /* Override previous blanket hide to enable animation */
        .project-manager-container.collapsed > :not(h3) { display: block; }

        /* Responsive tweaks */
        @media (max-width: 900px) {
            .container {
                padding: 1.75rem 1.25rem;
            }
        }

        @media (max-width: 700px) {
            .selectors-wrapper {
                flex-direction: column;
            }

            .choice-button-container {
                flex-direction: column;
            }

            .checklist-item {
                flex-direction: row;
            }
        }

        .search-tools {
            margin-top: 1rem;
            display: flex;
            gap: .5rem;
            justify-content: center;
        }

        .search-tools input[type="search"] {
            width: min(680px, 90%);
            padding: 10px 14px;
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--table-border);
            font-size: 1rem;
            outline: none;
        }

        .search-tools input[type="search"]:focus {
            box-shadow: var(--ring);
        }

        .search-tools button {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--header-border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 180ms ease;
        }

        .search-tools button:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .search-mark {
            background: rgba(255, 221, 87, 0.3);
            color: #ffd700;
            padding: 0 .1em;
            border-radius: 3px;
        }

        /* Skipped steps + numbering */
        .checklist-item.skipped { opacity: 0.5; }
        .checklist-item .step-index { font-weight: 700; margin-right: .35rem; color: var(--text-secondary); }
        .checklist-item .skip-btn {
            margin-left: 8px;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px dashed var(--header-border);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .checklist-item .skip-btn.active { color: var(--danger-color); border-color: var(--danger-color); }

        .fab-next {
            position: fixed;
            right: 24px;
            bottom: 24px;
            z-index: 20;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: .5rem;
            transition: all 180ms ease;
        }

        .fab-next:hover {
            background: #3182ce;
        }

        .fab-next:disabled {
            opacity: .5;
            cursor: not-allowed;
        }

        .fab-next .arrow {
            font-size: 1.1rem;
        }

        @keyframes pulseOutline {
            0% {
                border-color: var(--accent-primary);
                background-color: #1f3a5f;
            }
            100% {
                border-color: var(--header-border);
                background-color: var(--bg-secondary);
            }
        }

        @keyframes fadeSlideDown {
            from { opacity: 0; transform: translateY(-6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulseOutline 1200ms ease-out 1;
        }
        /* Hide legacy single/multi buttons in favor of Sessions dropdown */
        .choice-button-container { display: none !important; }

        header.compact-scrolled h1,
        header.compact-scrolled p {
            opacity: 0;
            max-height: 0;
            margin: 0;
            transform: translateY(-6px);
            pointer-events: none;
            overflow: hidden;
        }

        header.compact-scrolled .progress {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0 1rem;
        }
        header.compact-scrolled .progress-track { height: 6px; }
        header.compact-scrolled .collapsed-phases-strip { margin-top: 0.25rem; }

        /* Ensure full header content shows when not compact */
        header:not(.compact-scrolled) h1,
        header:not(.compact-scrolled) p {
            opacity: 1;
            max-height: 200px;
            transform: none;
            margin: initial;
            pointer-events: auto;
        }

        /* Checklist layout tweaks for skip button below checkbox */
        .checklist-item { align-items: flex-start; }
        .checklist-item .control-col { display: flex; flex-direction: column; align-items: center; margin-right: 16px; }
        .checklist-item .control-col .skip-btn { margin: 6px 0 0 0; }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Akhil's Astro Processing Workflow</h1>
            <p>An interactive guide for processing astrophotography data using Siril/Sirilic and some popular scripts</p>
            <div class="progress" aria-live="polite">
                <div class="progress-top">
                    <span>Progress</span>
                    <span id="progress-count">0/0</span>
                </div>
                <div class="progress-track" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div id="progress-fill"></div>
                </div>
            </div>
            <!-- Collapsed phases strip appears only while scrolled -->
            <div id="collapsed-phases-strip" class="collapsed-phases-strip" aria-live="polite" aria-label="Collapsed phases"></div>
            <div class="search-tools" role="search">
                <input id="search-steps" type="search" placeholder="Search steps, phases, tips..." aria-label="Search steps" />
                <button id="clear-search" type="button" aria-label="Clear search">Clear</button>
            </div>
        </header>

        <div class="project-manager-container collapsed">
            <h3>Project Manager <button id="pm-collapse-btn" class="toggle-btn" type="button" aria-label="Toggle section" aria-expanded="false">âˆ’</button></h3>
            <div class="pm-content">
                <label for="project-selector">Load Existing Project:</label>
                <select id="project-selector">
                    <option value="">-- Select a Project --</option>
                </select>
                <label for="project-name">Or Create a New Project:</label>
                <input type="text" id="project-name" placeholder="e.g., M31 - August Session">
                <div class="project-manager-buttons">
                    <button id="newProjectButton">Clear for New Project</button>
                    <button id="deleteProjectButton">Delete Selected Project</button>
                </div>
                <div class="note" aria-live="polite" style="margin-top:1rem;">
                    Projects are saved only in this browser (localStorage). Use Export/Import below to back up or move projects to another device.
                </div>
                <div class="project-manager-buttons" style="margin-top: 0.75rem;">
                    <button id="exportSelectedProjectButton" title="Export only the selected/entered project">Export Selected</button>
                    <button id="exportAllProjectsButton" title="Export all saved projects">Export All</button>
                    <button id="importProjectsButton" title="Import projects from a JSON file">Import JSON</button>
                    <input id="importProjectsInput" type="file" accept="application/json" style="display:none" />
                </div>
            </div>
        </div>

        <div class="target-selector-container">
            <div class="selectors-wrapper">
                <div>
                    <label for="session-type-choice">Filter</label>
                    <select id="session-type-choice">
                        <option value="dual-band">Dual-Band (L-Extreme, etc.)</option>
                        <option value="broadband">Broadband OSC (Galaxies, etc.)</option>
                    </select>
                </div>
                <div>
                    <label for="target-type-choice">Recommendation for</label>
                    <select id="target-type-choice">
                        <option value="large-nebula">Large, Diffuse Nebula</option>
                        <option value="small-nebula">Small / High-Detail Nebula</option>
                        <option value="galaxy">Galaxy / Star Cluster</option>
                    </select>
                </div>
                <div>
                    <label for="night-type-choice">Sessions</label>
                    <select id="night-type-choice">
                        <option value="single">Single night</option>
                        <option value="multi">Multi night</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="dual-band-workflow">
            <div id="single-night-workflow-db">
                <!-- DUAL BAND SINGLE NIGHT CONTENT -->
                <div class="phase">
                    <h2>Phase 1: Calibration & Extraction</h2>
                    <div class="phase-content">
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step1">
                            <div class="item-content">
                                <label for="db-s1-step1"><strong>Organize Files:</strong> Create a project folder with <span
                                        class="highlight-term">lights</span>, <span class="highlight-term">darks</span>,
                                    <span class="highlight-term">flats</span>, and <span
                                        class="highlight-term">biases</span> subfolders.</label>
                            </div>
                        </div>
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step2">
                            <div class="item-content">
                                <label for="db-s1-step2"><strong>Run Extraction Script:</strong> In Siril, set the home
                                    directory to your project folder. Run the built-in script: <span
                                        class="highlight-term">Scripts</span> -> <span
                                        class="highlight-term">OSC_Extract_HaOIII</span>.</label>
                                <div class="note">
                                    This script calibrates your files and separates the Ha and OIII signals, creating two
                                    new sequences in your `process` folder.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="phase">
                    <h2>Phase 2: Create Master Files</h2>
                    <div class="phase-content">
                        <h3>2a: Process OIII Channel</h3>
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step3">
                            <div class="item-content">
                                <label for="db-s1-step3"><strong>Cull OIII Frames:</strong> Load the <span
                                        class="highlight-term">OIII_pp_lights</span> sequence and exclude any bad
                                    frames.</label>
                            </div>
                        </div>
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step4">
                            <div class="item-content">
                                <label for="db-s1-step4"><strong>Stack OIII:</strong> Register the culled OIII sequence,
                                    then stack the result to create <span
                                        class="highlight-term">OIII_stacked.fit</span>.</label>
                            </div>
                        </div>
                        <h3>2b: Process Ha Channel</h3>
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step5">
                            <div class="item-content">
                                <label for="db-s1-step5"><strong>Cull Ha Frames:</strong> Load the <span
                                        class="highlight-term">Ha_pp_lights</span> sequence and exclude any bad
                                    frames.</label>
                            </div>
                        </div>
                        <div class="checklist-item">
                            <input type="checkbox" id="db-s1-step6">
                            <div class="item-content">
                                <label for="db-s1-step6"><strong>Stack Ha with Drizzle:</strong> Load the culled <span
                                        class="highlight-term">Ha_pp_lights</span> sequence. In the <span
                                        class="highlight-term">Registration</span> tab, select <span
                                        class="highlight-term">Drizzle</span>, set <strong>Scale</strong> to <span
                                        class="highlight-term">2.0</span> and <strong>Drop shrink</strong> to <span
                                        class="highlight-term">0.5</span>. Register, then stack to create <span
                                        class="highlight-term">Ha_stacked.fit</span>.</label>
                                <div class="note">
                                    <strong>Why Drizzle Ha?</strong> Drizzle is essential here to restore the resolution of
                                    the Ha channel. We don't drizzle OIII because it doesn't suffer the same resolution
                                    loss.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="multi-night-workflow-db" style="display: none;">
                <!-- DUAL BAND MULTI NIGHT CONTENT -->
                <div class="phase">
                    <h2>Phase 1: Automated Processing with Sirilic</h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-m1-step1">
                        <div class="item-content">
                            <label for="db-m1-step1"><strong>Configure Sirilic Project:</strong> Create a new project in
                                Sirilic. Point it to your folders containing all your lights and calibration frames from
                                all sessions.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-m1-step2">
                        <div class="item-content">
                            <label for="db-m1-step2"><strong>Define Layers:</strong> In Sirilic, define your two main
                                output layers: <span class="highlight-term">Ha</span> and <span
                                    class="highlight-term">OIII</span>.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-m1-step3">
                        <div class="item-content">
                            <label for="db-m1-step3"><strong>Configure Drizzle for Ha Layer:</strong> In the layer
                                settings for your Ha channel, enable drizzle and set the scale to <span
                                    class="highlight-term">2.0</span>.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-m1-step4">
                        <div class="item-content">
                            <label for="db-m1-step4"><strong>Configure Final Alignment:</strong> Ensure Sirilic is set
                                to align the final stacked layers to each other.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-m1-step5">
                        <div class="item-content">
                            <label for="db-m1-step5"><strong>Run Sirilic:</strong> Execute the process. Sirilic will
                                automate the entire pre-processing, extraction, registration, and stacking
                                workflow.</label>
                            <div class="note">
                                <strong>Manual Culling Tip:</strong> For best results, cull your raw light frames
                                *before* running Sirilic. Use Siril's Blink feature to review your lights and move any
                                bad ones to a separate folder.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="common-dual-band-steps">
                <!-- DUAL BAND COMMON STEPS -->
                <div class="phase" id="db-common-phase-1">
                    <h2 data-phase-single="Phase 3: Align & Process Masters"
                        data-phase-multi="Phase 2: Align & Process Masters"></h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step1">
                        <div class="item-content">
                            <label for="db-c-step1"><strong>Align Masters:</strong> Register your two stacked masters
                                (<span class="highlight-term">Ha_stacked.fit</span> and <span
                                    class="highlight-term">OIII_stacked.fit</span>) to each other to perfectly align
                                them and crop to the common area.</label>
                            <div class="note">
                                <strong>How-To:</strong> Create a new folder, copy both masters into it, set it as
                                Siril's home directory, use the `Conversion` tab to make a 2-frame sequence, and then
                                `Register` that sequence.
                            </div>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step2">
                        <div class="item-content">
                            <label for="db-c-step2"><strong>Final Crop:</strong> Draw a crop on one aligned master to
                                remove bad edges. Apply the *exact same crop* to the other master.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step2b">
                        <div class="item-content">
                            <label for="db-c-step2b"><strong>Optional: Software Bin 2x2:</strong> If undersampled or for smoother noise, use <span class="highlight-term">Resample</span> and set scale to <strong>0.5</strong> for X and Y. Save as new images.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step3">
                        <div class="item-content">
                            <label for="db-c-step3"><strong>Background Extraction:</strong> Run <span
                                    class="highlight-term">Background Extraction</span> on each of the cropped Ha and
                                OIII masters separately.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step4">
                        <div class="item-content">
                            <label for="db-c-step4"><strong>Denoise (Linear):</strong> Run the <span
                                    class="highlight-term">CC_Denoise</span> script on each linear master. Ensure the
                                <strong>Linear</strong> box is checked.</label>
                            <div class="note">
                                <a href="#appendix">See the Appendix</a> for recommended starting values.
                            </div>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step5">
                        <div class="item-content">
                            <label for="db-c-step5"><strong>Balance Signals:</strong> Open your processed OIII image.
                                Use <span class="highlight-term">Image Processing</span> -> <span
                                    class="highlight-term">Linear Match</span>, with the processed Ha image as the
                                "Reference Image". <strong>Save</strong> the matched OIII image.</label>
                        </div>
                    </div>
                </div>
                <div class="phase" id="db-common-phase-2">
                    <h2 data-phase-single="Phase 4: Color & Enhancement"
                        data-phase-multi="Phase 3: Color & Enhancement"></h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="db-c-step6">
                        <div class="item-content">
                            <label for="db-c-step6"><strong>Create Color Image:</strong> Combine your Ha and OIII
                                masters into a color image. For creative control, use the <span
                                    class="highlight-term">Pixel Math</span> tool with the formulas below.</label>
                            <div class="palette-selector">
                                <label for="palette-choice">Choose a Palette:</label>
                                <select id="palette-choice">
                                    <option value="hoo_standard">Standard HOO (Gold & Cyan)</option>
                                    <option value="hoo_custom">Custom HOO (Orange & Teal)</option>
                                    <option value="dynamic_blend">Dynamic Blend (Red & Blue)</option>
                                    <option value="sho_hubble">SHO (Hubble Palette)</option>
                                    <option value="hso_custom">HSO Palette</option>
                                </select>
                                <div id="palette-info-container"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="broadband-workflow" style="display: none;">
            <div id="single-night-workflow-bb">
                <!-- BROADBAND SINGLE NIGHT WORKFLOW CONTENT -->
                <div class="phase">
                    <h2>Phase 1: Calibration</h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-s1-step1">
                        <div class="item-content">
                            <label for="bb-s1-step1"><strong>Organize Files:</strong> Create a project folder with <span
                                    class="highlight-term">lights</span>, <span class="highlight-term">darks</span>,
                                <span class="highlight-term">flats</span>, and <span
                                    class="highlight-term">biases</span> subfolders.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-s1-step2">
                        <div class="item-content">
                            <label for="bb-s1-step2"><strong>Run Calibration Script:</strong> In Siril, set the home
                                directory to your project folder. Run the built-in script: <span
                                    class="highlight-term">Scripts</span> -> <span
                                    class="highlight-term">OSC_Preprocessing_WithoutDB</span>.</label>
                            <div class="note">
                                This script calibrates your light frames but stops before Debayering, leaving them as a
                                raw CFA sequence (<span class="highlight-term">pp_light_...</span>) ready for the next
                                steps.
                            </div>
                        </div>
                    </div>
                </div>
                <div class="phase">
                    <h2>Phase 2: Culling & Stacking with Bayer Drizzle</h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-s1-step3">
                        <div class="item-content">
                            <label for="bb-s1-step3"><strong>Manual Culling:</strong> Load the calibrated <span
                                    class="highlight-term">pp_light_...</span> sequence. Review each frame and exclude
                                any with issues.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-s1-step4">
                        <div class="item-content">
                            <label for="bb-s1-step4"><strong>Register & Stack with Bayer Drizzle:</strong> Register the
                                culled sequence using the <span class="highlight-term">Bayer Drizzle</span> registration
                                method (Scale 1.0). Then, stack the resulting registered sequence.</label>
                            <div class="note">
                                <strong>Bayer Drizzle is Key:</strong> This process is a superior alternative to
                                standard Debayering. It uses information from your dithered frames to reconstruct color
                                with higher fidelity and resolution.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="multi-night-workflow-bb" style="display: none;">
                <!-- BROADBAND MULTI NIGHT WORKFLOW CONTENT -->
                <div class="phase">
                    <h2>Phase 1: Automated Processing with Sirilic</h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-m1-step1">
                        <div class="item-content">
                            <label for="bb-m1-step1"><strong>Configure Sirilic Project:</strong> Create a new project in
                                Sirilic. Point it to your folders containing all your lights and calibration frames from
                                all sessions.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-m1-step2">
                        <div class="item-content">
                            <label for="bb-m1-step2"><strong>Define Layer:</strong> In Sirilic, define a single main
                                output layer (e.g., <span class="highlight-term">RGB</span>). Ensure it is set to
                                process as a standard OSC/Broadband target.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-m1-step3">
                        <div class="item-content">
                            <label for="bb-m1-step3"><strong>Configure Bayer Drizzle:</strong> In the layer settings,
                                ensure that Bayer Drizzle is the selected stacking method to achieve the best color and
                                detail.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-m1-step4">
                        <div class="item-content">
                            <label for="bb-m1-step4"><strong>Run Sirilic:</strong> Execute the process. Sirilic will
                                automate the entire pre-processing, calibration, registration, and stacking workflow for
                                all your sessions.</label>
                            <div class="note">
                                <strong>Manual Culling Tip:</strong> For best results, cull your raw light frames
                                *before* running Sirilic. Use Siril's Blink feature to review your lights and move any
                                bad ones to a separate folder.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="common-broadband-steps">
                <div class="phase">
                    <h2>Phase 3: Linear Processing</h2>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-c-step5">
                        <div class="item-content">
                            <label for="bb-c-step5"><strong>Final Crop:</strong> Open your final stacked color image and
                                crop out any remaining stacking artifacts.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-c-step5b">
                        <div class="item-content">
                            <label for="bb-c-step5b"><strong>Optional: Software Bin 2x2:</strong> If needed, use <span class="highlight-term">Resample</span> and set scale to <strong>0.5</strong> for X and Y to bin 2x2. Save as a new image.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-c-step6">
                        <div class="item-content">
                            <label for="bb-c-step6"><strong>Photometric Color Calibration:</strong> This is a crucial
                                step for broadband. Plate solve the image, then run <span
                                    class="highlight-term">Spectrophotometric Color Calibration (SPCC)</span> to get
                                accurate star and galaxy colors.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-c-step7">
                        <div class="item-content">
                            <label for="bb-c-step7"><strong>Background Extraction:</strong> Run <span
                                    class="highlight-term">Background Extraction</span> on the color-calibrated
                                image.</label>
                        </div>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="bb-c-step8">
                        <div class="item-content">
                            <label for="bb-c-step8"><strong>Denoise (Linear):</strong> Run the <span
                                    class="highlight-term">CC_Denoise</span> script on the linear color image. Ensure
                                the <strong>Linear</strong> box is checked.</label>
                            <div class="note">
                                <a href="#appendix">See the Appendix</a> for recommended starting values.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="common-enhancement-steps">
            <div class="phase" id="common-phase-2">
                <h2 data-phase-single="Phase 4: Color & Enhancement" data-phase-multi="Phase 3: Color & Enhancement"
                    data-phase-broadband="Phase 4: Enhancement"></h2>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step7">
                    <div class="item-content">
                        <label for="c-step7"><strong>Remove Stars:</strong> Use Siril's <span
                                class="highlight-term">StarNet++</span> tool on the processed **linear** color image to
                            create a <span class="highlight-term">starless</span> and a <span
                                class="highlight-term">stars_only</span> image.</label>
                        <div class="note">
                            <strong>Siril Tip:</strong> Check the "pre-stretch linear image" box in StarNet++. This
                            helps the AI find stars more accurately on linear data.
                        </div>
                    </div>
                </div>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step8">
                    <div class="item-content">
                        <label for="c-step8"><strong>Stretch Starless Image:</strong> Use the <span
                                class="highlight-term">StatisticalStretch</span> script on the <span
                                class="highlight-term">starless</span> linear image to bring it to a non-linear
                            state.</label>
                        <div class="note" id="stretch-note-content"></div>
                    </div>
                </div>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step9">
                    <div class="item-content">
                        <label for="c-step9"><strong>Sharpen Starless Image:</strong> Open the stretched <span
                                class="highlight-term">starless</span> color image. Run the <span
                                class="highlight-term">CC_Sharpen</span> script. Set <strong>Sharpening Mode</strong> to
                            <span class="highlight-term">non-stellar</span> and adjust the sliders.</label>
                        <div class="note" id="sharpen-note-content"></div>
                    </div>
                </div>
            </div>

            <div class="phase" id="common-phase-3">
                <h2 data-phase-single="Phase 5: Final Assembly" data-phase-multi="Phase 4: Final Assembly"
                    data-phase-broadband="Phase 5: Final Assembly"></h2>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step10">
                    <div class="item-content">
                        <label for="c-step10"><strong>Process Stars:</strong> Open the <span
                                class="highlight-term">stars_only</span> image. Apply a gentle stretch (e.g.,
                            ArcsinhStretch), adjust color saturation, or use star reduction as desired.</label>
                    </div>
                </div>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step11">
                    <div class="item-content">
                        <label for="c-step11"><strong>Recombine Stars:</strong> Use the <span
                                class="highlight-term">Star Recomposition</span> tool in Siril to add your processed
                            stars back to your sharpened, starless nebula image.</label>
                    </div>
                </div>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step12">
                    <div class="item-content">
                        <label for="c-step12"><strong>Final Touches:</strong> Make any final adjustments to curves or
                            color saturation on the final composite image.</label>
                    </div>
                </div>
                <div class="checklist-item">
                    <input type="checkbox" id="c-step13">
                    <div class="item-content">
                        <label for="c-step13"><strong>Save Your Image:</strong> Save the final result as a 32-bit TIFF
                            for maximum quality, and a separate copy as a JPG or PNG for sharing.</label>
                    </div>
                </div>
            </div>
        </div>


        <div class="phase collapsed" id="appendix">
            <h2>Appendix: Parameter Guide</h2>
            <p>These are recommended <strong>starting points</strong>. Always start with low values and adjust based on
                your results.</p>
            <div class="note" style="margin-left: 0; margin-bottom: 2rem;">
                <strong>A Note on Linear vs. Non-Linear Settings:</strong><br>
                - The <span class="highlight-term">CC_Denoise</span> script may have a 'Linear' checkbox. It must be
                <strong>checked</strong> when processing linear images.<br>
                - The <span class="highlight-term">CC_Sharpen</span> script (v1.0.7+) does not have this option and
                should only be used on <strong>non-linear (stretched)</strong> images.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>Target Type</th>
                        <th>Recommended Settings</th>
                        <th>Rationale & Key Considerations</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Statistical Stretch</strong></td>
                        <td><strong>Large, Diffuse Nebula</strong></td>
                        <td id="stretch-params-large-nebula"><strong>Target Median:</strong> 0.10 -
                            0.18<br><strong>Curves Boost:</strong> 0.0 - 0.05</td>
                        <td>A gentle stretch is needed to reveal faint detail without amplifying noise or crushing the
                            soft gradients of the nebula. The goal is subtlety.</td>
                    </tr>
                    <tr>
                        <td><strong>Statistical Stretch</strong></td>
                        <td><strong>Small / High-Detail Nebula</strong></td>
                        <td id="stretch-params-small-nebula"><strong>Target Median:</strong> 0.15 -
                            0.22<br><strong>Curves Boost:</strong> 0.05 - 0.10</td>
                        <td>These targets have bright cores and can handle a slightly stronger stretch. This helps
                            control the core while enhancing surrounding structure.</td>
                    </tr>
                    <tr>
                        <td><strong>Statistical Stretch</strong></td>
                        <td><strong>Galaxy / Star Cluster</strong></td>
                        <td id="stretch-params-galaxy"><strong>Target Median:</strong> 0.18 - 0.25<br><strong>Curves
                                Boost:</strong> 0.10 - 0.20</td>
                        <td>Requires a more aggressive stretch to make the faint outer arms "pop." The higher median
                            lifts the arms, and the boost adds defining contrast.</td>
                    </tr>
                    <tr>
                        <td><strong>Sharpening</strong></td>
                        <td><strong>Large, Diffuse Nebula</strong></td>
                        <td id="sharpen-params-large-nebula"><strong>Mode:</strong> <span
                                class="highlight-term">non-stellar</span><br><strong>Amount:</strong> 0.20 -
                            0.35<br><strong>Strength:</strong> Default</td>
                        <td>These targets are soft by nature. A gentle touch enhances detail without creating a harsh,
                            unnatural texture. Always use the `non-stellar` mode on a starless image for best results.
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Sharpening</strong></td>
                        <td><strong>Small / High-Detail Nebula</strong></td>
                        <td id="sharpen-params-small-nebula"><strong>Mode:</strong> <span
                                class="highlight-term">non-stellar</span><br><strong>Amount:</strong> 0.30 -
                            0.50<br><strong>Strength:</strong> Default</td>
                        <td>Objects with more defined structures can handle slightly more aggressive sharpening. Still,
                            start low and increase cautiously to avoid artifacts.</td>
                    </tr>
                    <tr>
                        <td><strong>Sharpening</strong></td>
                        <td><strong>Galaxy / Star Cluster</strong></td>
                        <td id="sharpen-params-galaxy"><strong>Mode:</strong> <span
                                class="highlight-term">non-stellar</span><br><strong>Amount:</strong> 0.25 -
                            0.45<br><strong>Strength:</strong> Default</td>
                        <td>Treat galaxies as "non-stellar" objects. Be careful not to over-sharpen the core. The goal
                            is to enhance dust lanes and spiral arms without making the core look artificial.</td>
                    </tr>
                    <tr>
                        <td><strong>Denoising</strong></td>
                        <td><strong>All Targets (from Bortle 9)</strong></td>
                        <td><strong>Type:</strong> <span
                                class="highlight-term">Luminance</span><br><strong>Amount:</strong> 0.40 - 0.60</td>
                        <td>For light-polluted skies, noise is a primary issue. The `Luminance` setting is best practice
                            as it aggressively targets brightness noise while preserving color information.</td>
                    </tr>
                    <tr>
                        <td><strong>Denoising</strong></td>
                        <td><strong>(Alternative for very noisy data)</strong></td>
                        <td><strong>Type:</strong> <span class="highlight-term">Full</span><br><strong>Amount:</strong>
                            0.30 - 0.50</td>
                        <td>If the `Luminance` setting isn't enough, use `Full`. Apply it more gently, as it can soften
                            fine color details if the amount is set too high.</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="button-container">
            <button id="resetButton">Reset Current Project Checklist</button>
        </div>

        <button id="next-step-fab" class="fab-next" title="Jump to next unchecked step">
            Next step <span class="arrow">â†’</span>
        </button>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const UI_PREFS_KEY = 'akhilAstroUiPrefs';
        const loadPrefs = () => { try { return JSON.parse(localStorage.getItem(UI_PREFS_KEY)) || {}; } catch { return {}; } };
        const savePrefs = (p) => { localStorage.setItem(UI_PREFS_KEY, JSON.stringify({ ...loadPrefs(), ...p })); };

        // Elements
        const body = document.body;
        const headerEl = document.querySelector('header');
        const collapsedStrip = document.getElementById('collapsed-phases-strip');
        const pmContainer = document.querySelector('.project-manager-container');
        const pmBtn = document.getElementById('pm-collapse-btn');
        const pmContent = pmContainer ? pmContainer.querySelector('.pm-content') : null;
        const sessionSel = document.getElementById('session-type-choice');
        const nightSel = document.getElementById('night-type-choice');
        const dualBand = document.getElementById('dual-band-workflow');
        const broadband = document.getElementById('broadband-workflow');
        const snDb = document.getElementById('single-night-workflow-db');
        const mnDb = document.getElementById('multi-night-workflow-db');
        const snBb = document.getElementById('single-night-workflow-bb');
        const mnBb = document.getElementById('multi-night-workflow-bb');
        const progressCountEl = document.getElementById('progress-count');
        const progressFillEl = document.getElementById('progress-fill');
        const progressTrackEl = document.querySelector('.progress-track');

        // Utilities
        function debounce(fn, delay) {
          let t;
          return function(...args) {
            clearTimeout(t);
            t = setTimeout(() => fn.apply(this, args), delay);
          };
        }

        // Hoisted FAB state updater (reassigned when FAB initializes)
        let updateFabState = () => {};

        // Update headings based on session/night selection
        function updatePhaseHeadings() {
          const isBroad = sessionSel && sessionSel.value === 'broadband';
          const night = nightSel ? nightSel.value : 'single';
          document.querySelectorAll('h2[data-phase-single], h2[data-phase-multi], h2[data-phase-broadband]').forEach(h2 => {
            const ds = h2.dataset;
            let text = '';
            if (isBroad && ds.phaseBroadband) {
              text = ds.phaseBroadband;
            } else if (night === 'multi' && ds.phaseMulti) {
              text = ds.phaseMulti;
            } else if (ds.phaseSingle) {
              text = ds.phaseSingle;
            }
            if (text) {
              const toggle = h2.querySelector('.toggle-btn');
              h2.textContent = text;
              if (toggle) h2.appendChild(toggle);
            }
          });
        }

        // Collapsible phases with toggle buttons
        function initCollapsibles() {
          document.querySelectorAll('.phase').forEach(phase => {
            const h2 = phase.querySelector('h2');
            if (!h2) return;
            
            // Wrap content in phase-content div if not already wrapped
            const existingContent = phase.querySelector('.phase-content');
            if (!existingContent) {
              const content = document.createElement('div');
              content.className = 'phase-content';
              Array.from(phase.children).forEach(child => {
                if (child !== h2) content.appendChild(child);
              });
              phase.appendChild(content);
            }
            
            if (!h2.querySelector('.toggle-btn')) {
              const btn = document.createElement('button');
              btn.className = 'toggle-btn';
              btn.type = 'button';
              btn.setAttribute('aria-label', 'Toggle section');
              btn.textContent = 'âˆ’';
              h2.appendChild(btn);
              btn.addEventListener('click', () => {
                const collapsed = phase.classList.toggle('collapsed');
                btn.textContent = collapsed ? '+' : 'âˆ’';
                updateProgress();
                updateCollapsedPhasesStrip();
              });
            }
          });
        }

        // Collapse Appendix by default on first load
        function collapseAppendixByDefault() {
          const appendix = document.getElementById('appendix');
          const phase = appendix ? (appendix.classList.contains('phase') ? appendix : appendix.closest('.phase')) : null;
          if (phase && !phase.classList.contains('collapsed')) {
            phase.classList.add('collapsed');
            const b = phase.querySelector('.toggle-btn');
            if (b) b.textContent = '+';
          }
        }

        // Project Manager collapse toggle + persistence + animation
        if (pmBtn && pmContainer) {
          pmBtn.addEventListener('click', () => {
            const isNowCollapsed = !pmContainer.classList.contains('collapsed');
            // Animate height
            if (pmContent) {
              if (!isNowCollapsed) {
                // Expanding
                pmContainer.classList.remove('collapsed');
                pmContent.style.maxHeight = pmContent.scrollHeight + 'px';
                pmContent.style.opacity = '1';
                pmContent.addEventListener('transitionend', function tidy(e){
                  if (e.propertyName === 'max-height') {
                    pmContent.style.maxHeight = '1200px';
                    pmContent.removeEventListener('transitionend', tidy);
                  }
                });
              } else {
                // Collapsing
                pmContent.style.maxHeight = pmContent.scrollHeight + 'px';
                // Force reflow
                void pmContent.offsetHeight;
                pmContainer.classList.add('collapsed');
              }
            } else {
              pmContainer.classList.toggle('collapsed');
            }
            const isCollapsed = pmContainer.classList.contains('collapsed');
            pmBtn.textContent = isCollapsed ? '+' : 'âˆ’';
            pmBtn.setAttribute('aria-expanded', String(!isCollapsed));
            savePrefs({ pmCollapsed: isCollapsed });
          });
        }

        // Restore UI prefs
        const prefs = loadPrefs();
        if (typeof prefs.pmCollapsed === 'boolean' && pmContainer) {
          pmContainer.classList.toggle('collapsed', prefs.pmCollapsed);
          if (pmBtn) {
            const isCollapsed = pmContainer.classList.contains('collapsed');
            pmBtn.textContent = isCollapsed ? '+' : 'âˆ’';
            pmBtn.setAttribute('aria-expanded', String(!isCollapsed));
          }
        } else if (pmContainer && pmBtn) {
          // Default to collapsed on first load
          pmContainer.classList.add('collapsed');
          pmBtn.textContent = '+';
          pmBtn.setAttribute('aria-expanded', 'false');
        }
        if (prefs.sessionType && sessionSel) sessionSel.value = prefs.sessionType;
        if (prefs.nightType && nightSel) nightSel.value = prefs.nightType;

        // Session & Night selectors wiring
        function applyNight() {
          const n = nightSel ? nightSel.value : 'single';
          const isBroad = sessionSel && sessionSel.value === 'broadband';
          if (isBroad) {
            if (snBb) snBb.style.display = n === 'single' ? 'block' : 'none';
            if (mnBb) mnBb.style.display = n === 'multi' ? 'block' : 'none';
          } else {
            if (snDb) snDb.style.display = n === 'single' ? 'block' : 'none';
            if (mnDb) mnDb.style.display = n === 'multi' ? 'block' : 'none';
          }
          savePrefs({ nightType: n });
          updatePhaseHeadings();
          enhanceSteps();
          updateProgress();
          updateCollapsedPhasesStrip();
          if (typeof updateFabState === 'function') updateFabState();
        }

        function applySession() {
          const isBroad = sessionSel && sessionSel.value === 'broadband';
          if (dualBand) dualBand.style.display = isBroad ? 'none' : 'block';
          if (broadband) broadband.style.display = isBroad ? 'block' : 'none';
          savePrefs({ sessionType: sessionSel ? sessionSel.value : 'dual-band' });
          updatePhaseHeadings();
          applyNight();
          enhanceSteps();
          if (typeof updateFabState === 'function') updateFabState();
        }

        if (sessionSel) sessionSel.addEventListener('change', applySession);
        if (nightSel) nightSel.addEventListener('change', applyNight);

        // Progress
        function getVisibleCheckboxes() {
          return Array.from(document.querySelectorAll('input[type="checkbox"]')).filter(cb => cb.offsetParent !== null);
        }
        function updateProgress() {
          if (!progressCountEl || !progressFillEl || !progressTrackEl) return;
          const visible = getVisibleCheckboxes();
          const total = visible.length;
          const checked = visible.filter(cb => cb.checked && !cb.closest('.checklist-item')?.classList.contains('skipped')).length;
          const skippedVisible = visible.filter(cb => cb.closest('.checklist-item')?.classList.contains('skipped')).length;
          const effectiveTotal = total; // Show total visible steps (checked + unchecked + skipped)
          const pct = effectiveTotal ? Math.round((checked / effectiveTotal) * 100) : 0;
          progressCountEl.textContent = `${checked}/${effectiveTotal}`;
          progressFillEl.style.width = pct + '%';
          progressTrackEl.setAttribute('aria-valuenow', String(pct));
        }
        document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.addEventListener('change', updateProgress));

        // Step numbering + Skip feature
        function enhanceSteps() {
          const allItems = Array.from(document.querySelectorAll('.checklist-item'));
          let idx = 1;
          allItems.forEach(item => {
            // Numbering
            if (!item.querySelector('.step-index')) {
              const indexSpan = document.createElement('span');
              indexSpan.className = 'step-index';
              indexSpan.textContent = idx + '.';
              const content = item.querySelector('.item-content');
              if (content && content.firstChild) {
                content.insertBefore(indexSpan, content.firstChild);
              } else if (content) {
                content.appendChild(indexSpan);
              }
            } else {
              item.querySelector('.step-index').textContent = idx + '.';
            }

            // Create/ensure control column
            let controlCol = item.querySelector('.control-col');
            if (!controlCol) {
              controlCol = document.createElement('div');
              controlCol.className = 'control-col';
              // Move existing checkbox into control column
              const cb = item.querySelector('input[type="checkbox"]');
              if (cb) {
                item.insertBefore(controlCol, cb);
                controlCol.appendChild(cb);
              } else {
                item.insertBefore(controlCol, item.firstChild);
              }
            } else {
              // ensure checkbox is first in control column
              const cb = item.querySelector('input[type="checkbox"]');
              if (cb && cb.parentElement !== controlCol) {
                controlCol.insertBefore(cb, controlCol.firstChild);
              }
            }

            // Skip control under checkbox
            let skipBtn = item.querySelector('.skip-btn');
            if (!skipBtn) {
              skipBtn = document.createElement('button');
              skipBtn.type = 'button';
              skipBtn.className = 'skip-btn';
              skipBtn.textContent = 'Skip';
              skipBtn.addEventListener('click', () => {
                const isSkipped = item.classList.toggle('skipped');
                skipBtn.classList.toggle('active', isSkipped);
                skipBtn.textContent = isSkipped ? 'Unskip' : 'Skip';
                updateProgress();
                if (typeof updateFabState === 'function') updateFabState();
              });
              controlCol.appendChild(skipBtn);
            } else if (skipBtn.parentElement !== controlCol) {
              controlCol.appendChild(skipBtn);
            }

            idx += 1;
          });
        }

        // Build/update collapsed phases strip
        function updateCollapsedPhasesStrip() {
          if (!collapsedStrip) return;
          // Only show when header is compact
          const compact = headerEl && headerEl.classList.contains('compact-scrolled');
          collapsedStrip.innerHTML = '';
          if (!compact) return;
          const phases = Array.from(document.querySelectorAll('.phase'))
            .filter(ph => ph.classList.contains('collapsed') && isVisible(ph));
          phases.forEach(ph => {
            const h2 = ph.querySelector('h2');
            if (!h2) return;
            const clone = h2.cloneNode(true);
            clone.querySelectorAll('button').forEach(b => b.remove());
            const title = (clone.textContent || '').trim();
            // Optional per-phase progress
            const cbs = Array.from(ph.querySelectorAll('input[type="checkbox"]')).filter(cb => isVisible(cb));
            const total = cbs.length;
            const checked = cbs.filter(cb => cb.checked).length;
            const chip = document.createElement('button');
            chip.className = 'phase-chip';
            chip.type = 'button';
            chip.title = 'Jump to and expand: ' + title;
            chip.innerHTML = `${title}${total ? `<span class="count">(${checked}/${total})</span>` : ''}`;
            chip.addEventListener('click', () => {
              // Expand this phase and scroll to it
              ph.classList.remove('collapsed');
              const btn = ph.querySelector('.toggle-btn');
              if (btn) btn.textContent = 'âˆ’';
              ph.scrollIntoView({ behavior: 'smooth', block: 'start' });
              updateProgress();
              updateCollapsedPhasesStrip();
            });
            collapsedStrip.appendChild(chip);
          });
        }

        // Sticky header: hide title/intro when scrolling (throttled with rAF)
        let lastCompact = false;
        let scrollScheduled = false;
        const onScroll = () => {
          if (scrollScheduled) return;
          scrollScheduled = true;
          requestAnimationFrame(() => {
            const compact = window.scrollY > 36;
            if (headerEl && compact !== lastCompact) {
              headerEl.classList.toggle('compact-scrolled', compact);
              lastCompact = compact;
              updateCollapsedPhasesStrip();
            }
            scrollScheduled = false;
          });
        };
        window.addEventListener('scroll', onScroll, { passive: true });

        // FAB Next Step Button
        const fabBtn = document.getElementById('next-step-fab');
        if (fabBtn) {
          fabBtn.addEventListener('click', () => {
            const visible = getVisibleCheckboxes();
            const nextUnchecked = visible.find(cb => !cb.checked);
            if (nextUnchecked) {
              // Expand parent phase if collapsed
              const phase = nextUnchecked.closest('.phase');
              if (phase && phase.classList.contains('collapsed')) {
                phase.classList.remove('collapsed');
                const btn = phase.querySelector('.toggle-btn');
                if (btn) btn.textContent = 'âˆ’';
              }
              
              // Scroll to and highlight the step
              nextUnchecked.scrollIntoView({ behavior: 'smooth', block: 'center' });
              const item = nextUnchecked.closest('.checklist-item');
              if (item) {
                item.classList.add('pulse');
                setTimeout(() => item.classList.remove('pulse'), 900);
              }
              updateProgress();
              updateCollapsedPhasesStrip();
            }
          });

          // Update FAB button state based on progress
          updateFabState = function() {
            const visible = getVisibleCheckboxes();
            const hasUnchecked = visible.some(cb => !cb.checked);
            fabBtn.disabled = !hasUnchecked;
          };
          
          document.querySelectorAll('input[type="checkbox"]').forEach(cb => 
            cb.addEventListener('change', updateFabState)
          );
          updateFabState();
        }

        // Search functionality
        const searchInput = document.getElementById('search-steps');
        const clearBtn = document.getElementById('clear-search');
        let searchState = { expanded: new Set(), query: '' };

        function highlightText(text, query) {
          if (!query) return text;
          const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          return text.replace(regex, '<mark class="search-mark">$1</mark>');
        }

        function performSearch(query) {
          const phases = document.querySelectorAll('.phase');
          const phaseList = Array.from(phases);
          let hasResults = false;

          phaseList.forEach(phase => {
            let phaseHasMatch = false;
            const items = phase.querySelectorAll('.checklist-item, .note, h3, p');
            
            items.forEach(item => {
              const text = item.textContent.toLowerCase();
              const matches = !query || text.includes(query.toLowerCase());
              
              if (matches && query) {
                // Highlight matches
                const walker = document.createTreeWalker(
                  item, NodeFilter.SHOW_TEXT, null, false
                );
                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                  textNodes.push(node);
                }
                
                textNodes.forEach(textNode => {
                  if (textNode.textContent.toLowerCase().includes(query.toLowerCase())) {
                    const span = document.createElement('span');
                    span.className = 'search-wrap';
                    span.innerHTML = highlightText(textNode.textContent, query);
                    textNode.parentNode.replaceChild(span, textNode);
                  }
                });
                
                phaseHasMatch = true;
                hasResults = true;
              }
              
              item.style.display = matches ? '' : 'none';
            });

            // Show/hide entire phase based on matches
            if (query) {
              phase.style.display = phaseHasMatch ? '' : 'none';
              if (phaseHasMatch && phase.classList.contains('collapsed')) {
                searchState.expanded.add(phase.id || phaseList.indexOf(phase));
                phase.classList.remove('collapsed');
                const btn = phase.querySelector('.toggle-btn');
                if (btn) btn.textContent = 'âˆ’';
              }
            } else {
              phase.style.display = '';
              // Restore previous collapse state
              const id = phase.id || phaseList.indexOf(phase);
              if (searchState.expanded.has(id)) {
                searchState.expanded.delete(id);
                phase.classList.add('collapsed');
                const btn = phase.querySelector('.toggle-btn');
                if (btn) btn.textContent = '+';
              }
            }
          });

          updateProgress();
          updateCollapsedPhasesStrip();
        }

        function removeSearchHighlights() {
          // Remove all search highlights and wrappers we added
          document.querySelectorAll('mark.search-mark').forEach(mark => {
            const parent = mark.parentNode;
            parent.replaceChild(document.createTextNode(mark.textContent), mark);
            parent.normalize();
          });
          document.querySelectorAll('span.search-wrap').forEach(span => {
            const parent = span.parentNode;
            parent.replaceChild(document.createTextNode(span.textContent), span);
            parent.normalize();
          });
        }

        function clearSearch() {
          removeSearchHighlights();
          performSearch('');
          if (searchInput) searchInput.value = '';
          searchState.query = '';
        }

        if (searchInput && clearBtn) {
          const debouncedSearch = debounce((val) => {
            removeSearchHighlights();
            if (val) {
              performSearch(val);
            } else {
              performSearch('');
            }
          }, 200);

          searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchState.query = query;
            debouncedSearch(query);
          });

          clearBtn.addEventListener('click', clearSearch);
        }

        // Palette Selection System
        const paletteData = {
          hoo_standard: {
            name: "Standard HOO (Gold & Cyan)",
            description: "Classic Ha-OIII combination with warm and cool tones",
            formulas: {
              R: "Ha*0.8 + OIII*0.2",
              G: "Ha*0.1 + OIII*0.9", 
              B: "OIII*1.0"
            }
          },
          hoo_custom: {
            name: "Custom HOO (Orange & Teal)",
            description: "Modern cinematic look with orange nebula and teal stars",
            formulas: {
              R: "Ha*1.0",
              G: "Ha*0.4 + OIII*0.6",
              B: "OIII*0.8"
            }
          },
          dynamic_blend: {
            name: "Dynamic Blend (Red & Blue)",
            description: "High contrast blend emphasizing structure",
            formulas: {
              R: "Ha*1.0 + OIII*0.1",
              G: "Ha*0.3 + OIII*0.4",
              B: "OIII*1.0 + Ha*0.1"
            }
          },
          sho_hubble: {
            name: "SHO (Hubble Palette)",
            description: "Space telescope inspired false-color mapping",
            formulas: {
              R: "OIII*1.0",
              G: "Ha*1.0", 
              B: "OIII*0.7 + Ha*0.3"
            }
          },
          hso_custom: {
            name: "HSO Palette",
            description: "Alternative mapping for unique aesthetic",
            formulas: {
              R: "Ha*0.9 + OIII*0.1",
              G: "OIII*0.6 + Ha*0.4",
              B: "OIII*1.0"
            }
          }
        };

        function renderPaletteInfo(paletteKey) {
          const container = document.getElementById('palette-info-container');
          if (!container) return;

          const palette = paletteData[paletteKey];
          if (!palette) {
            container.innerHTML = '';
            return;
          }

          container.innerHTML = `
            <div class="palette-info">
              <h4>${palette.name}</h4>
              <p>${palette.description}</p>
              <div class="palette-actions">
                <button class="btn-secondary copy-formulas" data-formulas='${JSON.stringify(palette.formulas)}'>
                  Copy Formulas
                </button>
              </div>
              <pre>R: ${palette.formulas.R}
G: ${palette.formulas.G}  
B: ${palette.formulas.B}</pre>
            </div>
          `;

          // Add copy functionality
          const copyBtn = container.querySelector('.copy-formulas');
          if (copyBtn) {
            copyBtn.addEventListener('click', () => {
              const formulas = JSON.parse(copyBtn.dataset.formulas);
              const text = `R: ${formulas.R}\nG: ${formulas.G}\nB: ${formulas.B}`;
              navigator.clipboard.writeText(text).then(() => {
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy Formulas', 2000);
              }).catch(() => {
                copyBtn.textContent = 'Copy failed';
                setTimeout(() => copyBtn.textContent = 'Copy Formulas', 2000);
              });
            });
          }
        }

        const paletteSelector = document.getElementById('palette-choice');
        if (paletteSelector) {
          paletteSelector.addEventListener('change', (e) => {
            renderPaletteInfo(e.target.value);
          });
          // Render initial selection
          renderPaletteInfo(paletteSelector.value);
        }

        // Reset Button
        const resetBtn = document.getElementById('resetButton');
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset all checkboxes? This will clear your current progress.')) {
              document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
              });
              updateProgress();
              updateFabState();
            }
          });
        }

        // Project Management Implementation
        const PROJECTS_KEY = 'akhilAstroProjects';
        const CURRENT_PROJECT_KEY = 'akhilAstroCurrentProject';

        // Project management functions
        function getAllProjects() {
          try {
            return JSON.parse(localStorage.getItem(PROJECTS_KEY)) || {};
          } catch {
            return {};
          }
        }

        function saveProject(projectName, data) {
          const projects = getAllProjects();
          projects[projectName] = {
            projectName,
            timestamp: new Date().toISOString(),
            checkboxStates: data.checkboxStates || {},
            uiPreferences: data.uiPreferences || {}
          };
          localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
          localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
          populateProjectSelector();
        }

        function loadProject(projectName) {
          const projects = getAllProjects();
          const project = projects[projectName];
          if (!project) return false;

          // Restore checkbox states
          if (project.checkboxStates) {
            Object.entries(project.checkboxStates).forEach(([id, checked]) => {
              const checkbox = document.getElementById(id);
              if (checkbox) checkbox.checked = checked;
            });
          }

          // Restore UI preferences
          if (project.uiPreferences) {
            if (project.uiPreferences.sessionType && sessionSel) {
              sessionSel.value = project.uiPreferences.sessionType;
            }
            if (project.uiPreferences.targetType) {
              const targetSel = document.getElementById('target-type-choice');
              if (targetSel) targetSel.value = project.uiPreferences.targetType;
            }
            if (project.uiPreferences.nightType && nightSel) {
              nightSel.value = project.uiPreferences.nightType;
            }
          }

          localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
          updateProgress();
          applySession();
          return true;
        }

        function deleteProject(projectName) {
          const projects = getAllProjects();
          delete projects[projectName];
          localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
          
          const currentProject = localStorage.getItem(CURRENT_PROJECT_KEY);
          if (currentProject === projectName) {
            localStorage.removeItem(CURRENT_PROJECT_KEY);
          }
          
          populateProjectSelector();
        }

        function getCurrentProjectData() {
          const checkboxStates = {};
          document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            checkboxStates[cb.id] = cb.checked;
          });

          const uiPreferences = {
            sessionType: sessionSel ? sessionSel.value : 'dual-band',
            targetType: document.getElementById('target-type-choice')?.value || 'large-nebula',
            nightType: nightSel ? nightSel.value : 'single'
          };

          return { checkboxStates, uiPreferences };
        }

        function populateProjectSelector() {
          const selector = document.getElementById('project-selector');
          if (!selector) return;

          const projects = getAllProjects();
          const currentProject = localStorage.getItem(CURRENT_PROJECT_KEY);
          
          selector.innerHTML = '<option value="">-- Select a Project --</option>';
          
          Object.keys(projects).sort().forEach(projectName => {
            const option = document.createElement('option');
            option.value = projectName;
            option.textContent = projectName;
            if (projectName === currentProject) {
              option.selected = true;
            }
            selector.appendChild(option);
          });
        }

        function exportProject(projectName) {
          const projects = getAllProjects();
          const project = projects[projectName];
          if (!project) return;

          const dataStr = JSON.stringify([project], null, 2);
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          
          const link = document.createElement('a');
          link.href = url;
          link.download = `astrophotography-project-${projectName.replace(/[^a-z0-9]/gi, '_')}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }

        function exportAllProjects() {
          const projects = getAllProjects();
          const projectsArray = Object.values(projects);
          
          if (projectsArray.length === 0) {
            alert('No projects to export.');
            return;
          }

          const dataStr = JSON.stringify(projectsArray, null, 2);
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          
          const link = document.createElement('a');
          link.href = url;
          link.download = 'astrophotography-projects-all.json';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }

        function importProjects(file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const importedData = JSON.parse(e.target.result);
              const projects = getAllProjects();
              
              let importedCount = 0;
              const dataArray = Array.isArray(importedData) ? importedData : [importedData];
              
              dataArray.forEach(project => {
                if (project.projectName) {
                  projects[project.projectName] = project;
                  importedCount++;
                }
              });
              
              localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
              populateProjectSelector();
              alert(`Successfully imported ${importedCount} project(s).`);
            } catch (error) {
              alert('Error importing projects. Please check the file format.');
              console.error('Import error:', error);
            }
          };
          reader.readAsText(file);
        }

        // Auto-save current project data
        function autoSaveCurrentProject() {
          const currentProject = localStorage.getItem(CURRENT_PROJECT_KEY);
          const projectName = document.getElementById('project-name')?.value?.trim();
          
          if (currentProject || projectName) {
            const nameToUse = projectName || currentProject;
            const data = getCurrentProjectData();
            saveProject(nameToUse, data);
          }
        }

        // Project management event listeners
        const projectSelector = document.getElementById('project-selector');
        const projectNameInput = document.getElementById('project-name');
        const newProjectBtn = document.getElementById('newProjectButton');
        const deleteProjectBtn = document.getElementById('deleteProjectButton');
        const exportSelectedBtn = document.getElementById('exportSelectedProjectButton');
        const exportAllBtn = document.getElementById('exportAllProjectsButton');
        const importBtn = document.getElementById('importProjectsButton');
        const importInput = document.getElementById('importProjectsInput');

        if (projectSelector) {
          projectSelector.addEventListener('change', (e) => {
            const projectName = e.target.value;
            if (projectName) {
              loadProject(projectName);
              if (projectNameInput) projectNameInput.value = projectName;
            }
          });
        }

        if (projectNameInput) {
          projectNameInput.addEventListener('input', () => {
            // Clear selector when typing new name
            if (projectSelector) projectSelector.value = '';
          });
        }

        if (newProjectBtn) {
          newProjectBtn.addEventListener('click', () => {
            const projectName = projectNameInput?.value?.trim();
            if (!projectName) {
              alert('Please enter a project name first.');
              return;
            }
            
            // Clear all checkboxes
            document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
              cb.checked = false;
            });
            
            // Save the new empty project
            const data = getCurrentProjectData();
            saveProject(projectName, data);
            
            updateProgress();
            alert(`New project "${projectName}" created and ready.`);
          });
        }

        if (deleteProjectBtn) {
          deleteProjectBtn.addEventListener('click', () => {
            const selectedProject = projectSelector?.value;
            if (!selectedProject) {
              alert('Please select a project to delete.');
              return;
            }
            
            if (confirm(`Are you sure you want to delete the project "${selectedProject}"? This cannot be undone.`)) {
              deleteProject(selectedProject);
              if (projectNameInput) projectNameInput.value = '';
              alert(`Project "${selectedProject}" has been deleted.`);
            }
          });
        }

        if (exportSelectedBtn) {
          exportSelectedBtn.addEventListener('click', () => {
            const projectName = projectNameInput?.value?.trim() || projectSelector?.value;
            if (!projectName) {
              alert('Please select or enter a project name to export.');
              return;
            }
            
            // Save current state first
            const data = getCurrentProjectData();
            saveProject(projectName, data);
            
            exportProject(projectName);
          });
        }

        if (exportAllBtn) {
          exportAllBtn.addEventListener('click', exportAllProjects);
        }

        if (importBtn) {
          importBtn.addEventListener('click', () => {
            importInput?.click();
          });
        }

        if (importInput) {
          importInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
              importProjects(file);
              e.target.value = ''; // Clear the input
            }
          });
        }

        // Auto-save on checkbox changes
        document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.addEventListener('change', () => {
            setTimeout(autoSaveCurrentProject, 100); // Slight delay to batch changes
          });
        });

        // Auto-save on UI preference changes
        if (sessionSel) sessionSel.addEventListener('change', autoSaveCurrentProject);
        if (nightSel) nightSel.addEventListener('change', autoSaveCurrentProject);
        const targetSel = document.getElementById('target-type-choice');
        if (targetSel) targetSel.addEventListener('change', autoSaveCurrentProject);

        // Initialize project management
        populateProjectSelector();
        
        // Try to restore last project if no specific project is loaded
        const currentProject = localStorage.getItem(CURRENT_PROJECT_KEY);
        if (currentProject && projectNameInput) {
          projectNameInput.value = currentProject;
          if (projectSelector) projectSelector.value = currentProject;
        }

        // Initialize everything
        initCollapsibles();
        collapseAppendixByDefault();
        applySession();
        if (nightSel && !nightSel.value) nightSel.value = 'single';
        updatePhaseHeadings();
        enhanceSteps();
        updateProgress();
        updateCollapsedPhasesStrip();
        onScroll();
        if (typeof updateFabState === 'function') updateFabState();
      });
    </script>

</body>

</html>
